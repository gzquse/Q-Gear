*=================      ./simple_qcrank_EscherHands_backAer.py
Uses Aer
encode 2 sequnces of real numbers with  QCrank using  nq_data=2 qubits and common address qubits
compute vector : averag or difference
(optional) change relative weights

"--mathOp", choices=['add','sub','none'],
--exportQPY", help="export circuits in QPY format", .qpy file can be inspected using dump_qpyCircs.py 

Plot residua with       plot_EsherHands.py

 backend: aer
uses backRun

circ_orig depth_aziz: {'cx': 6, '2q': 6, '3q': 0, '4q+': 4, '1q': 9} , ops: {'ry': 10, 'cx': 10, 'barrier': 4, 'measure': 4, 'h': 2, 'rz': 2, 'qubits': 4}
                    ░ ┌───────────────┐     ┌───┐┌─────────────────┐┌───┐┌────────────────┐                        ┌───┐»
   q_0: ────────────░─┤ R(1.2402,π/2) ├─────┤ X ├┤ R(-0.27008,π/2) ├┤ X ├┤ R(-0.4448,π/2) ├────────────────────────┤ X ├»
                    ░ ├───────────────┤┌───┐└─┬─┘├─────────────────┤└─┬─┘└─────┬───┬──────┘┌─────────────────┐┌───┐└─┬─┘»
   q_1: ────────────░─┤ R(2.0179,π/2) ├┤ X ├──┼──┤ R(0.001959,π/2) ├──┼────────┤ X ├───────┤ R(-0.61621,π/2) ├┤ X ├──┼──»
        ┌─────────┐ ░ └───────────────┘└─┬─┘  │  └─────────────────┘  │        └─┬─┘       └─────────────────┘└─┬─┘  │  »
   q_2: ┤ U2(0,π) ├─░────────────────────■────┼───────────────────────■──────────┼──────────────────────────────■────┼──»
        ├─────────┤ ░                         │                                  │                                   │  »
   q_3: ┤ U2(0,π) ├─░─────────────────────────■──────────────────────────────────■───────────────────────────────────■──»
        └─────────┘ ░                                                                                                   »
meas: 4/════════════════════════════════════════════════════════════════════════════════════════════════════════════════»
                                                                                                                        »
«         ┌────────────────┐┌───┐      ░                 ┌────────────┐┌───┐┌─────────────┐ ░  ░ ┌─┐         
«   q_0: ─┤ R(0.41975,π/2) ├┤ X ├──────░──────────────■──┤ R(π/4,π/2) ├┤ X ├┤ R(-π/4,π/2) ├─░──░─┤M├─────────
«        ┌┴────────────────┤└─┬─┘┌───┐ ░ ┌─────────┐┌─┴─┐└┬──────────┬┘└─┬─┘└─────────────┘ ░  ░ └╥┘┌─┐      
«   q_1: ┤ R(-0.30534,π/2) ├──┼──┤ X ├─░─┤ U1(π/2) ├┤ X ├─┤ U1(-π/2) ├───■──────────────────░──░──╫─┤M├──────
«        └─────────────────┘  │  └─┬─┘ ░ └─────────┘└───┘ └──────────┘                      ░  ░  ║ └╥┘┌─┐   
«   q_2: ─────────────────────■────┼───░────────────────────────────────────────────────────░──░──╫──╫─┤M├───
«                                  │   ░                                                    ░  ░  ║  ║ └╥┘┌─┐
«   q_3: ──────────────────────────■───░────────────────────────────────────────────────────░──░──╫──╫──╫─┤M├
«                                      ░                                                    ░  ░  ║  ║  ║ └╥┘
«meas: 4/═════════════════════════════════════════════════════════════════════════════════════════╩══╩══╩══╩═
«                                                                                                 0  1  2  3 
M: acquire backend: aer


*=================   ./run_cudaq_qpyCircs.py
python3 -m pdb run_cudaq_qpyCircs.py  --expName exp_84adce

 INPUT: pair of hd5 + qpy
 Action:
 - opens hd5, reads qpy
 - converts qcL to qKerL (Qiskit -->CudaQ
 - run on single gpu node
 - compares results from CPU
 - saves updated HD5

*=================     ./ehands_grad_smooth_func1d_backAer.py
 backend: aer
uses backRun

  --nqAddr NQADDR       size of address registers
  -i NUMSAMPLE, --numSample NUMSAMPLE

 -O {grad,smooth,conv,mask}, --imgOp {grad,smooth,conv,mask}

Computes gradient of 1D func or smooths noisy 1D func
 encode 2 sequnces of real numbers using QCrank using 2  nq_data qubits
 compute vector : averag or difference

fixed weights=1/2  in EscherHands

 ./plot_EsherHands.py  --expName ibm_kgpamp  -Y
   ./plot_grad_smooth.py  --expName ibm_kgpamp  -Y


*=================   


*=================   