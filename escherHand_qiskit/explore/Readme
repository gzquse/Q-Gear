*=================               x0x1_EsherHands_backAer.py
Basic ONE EsehrHand circuit for 2 arbitrary inputs,
Output controlled by: --measBasis", choices=['x','y','z']
Uses Sampler()
computes  gradient and  average for a pair of real values stored as sqrt(amplitudes) on 2 qubits, w/o using any ancilla.

D2A: xV: [0.3, 0.9]  W: 0.5
     ┌──────────┐ ░                 ┌─────────┐┌───┐┌────────────┐ ░ ┌─┐   
q_0: ┤ Ry(θ[0]) ├─░──────────────■──┤ Ry(α/2) ├┤ X ├┤ Ry(-0.5*α) ├─░─┤M├───
     ├──────────┤ ░ ┌─────────┐┌─┴─┐└─────────┘└─┬─┘└────────────┘ ░ └╥┘┌─┐
q_1: ┤ Ry(θ[1]) ├─░─┤ Rz(π/2) ├┤ X ├─────────────■─────────────────░──╫─┤M├
     └──────────┘ ░ └─────────┘└───┘                               ░  ║ └╥┘
c: 2/═════════════════════════════════════════════════════════════════╩══╩═
                                                                      0  1 


notes for sum:
https://docs.google.com/document/d/1yiKcocSj7qq2Paa9DiR2W_f5eYqml5IOBfwyC0k7bUc/edit?usp=sharing

notes for difference:
https://docs.google.com/document/d/17imQIXXlJdt3-nkfXjxYvVlrI5C7f7rBJJO4QI8PToo/edit?usp=sharing



*=================              ideal_qcrank.py
Basic test of QCrank
.... PARAMETRIZED CIRCUIT .............. n_pix=8,  qcrank_opt=True, cx-depth=4
 gates count: OrderedDict([('ry', 8), ('cx', 8), ('measure', 4), ('h', 2), ('barrier', 2)])
              ░ ┌───────────┐     ┌───┐┌───────────┐     ┌───┐┌───────────┐     ┌───┐┌───────────┐     ┌───┐ ░ ┌─┐         
   q_0: ──────░─┤ Ry(p1[0]) ├─────┤ X ├┤ Ry(p1[1]) ├─────┤ X ├┤ Ry(p1[2]) ├─────┤ X ├┤ Ry(p1[3]) ├─────┤ X ├─░─┤M├─────────
              ░ ├───────────┤┌───┐└─┬─┘├───────────┤┌───┐└─┬─┘├───────────┤┌───┐└─┬─┘├───────────┤┌───┐└─┬─┘ ░ └╥┘┌─┐      
   q_1: ──────░─┤ Ry(p0[0]) ├┤ X ├──┼──┤ Ry(p0[1]) ├┤ X ├──┼──┤ Ry(p0[2]) ├┤ X ├──┼──┤ Ry(p0[3]) ├┤ X ├──┼───░──╫─┤M├──────
        ┌───┐ ░ └───────────┘└─┬─┘  │  └───────────┘└─┬─┘  │  └───────────┘└─┬─┘  │  └───────────┘└─┬─┘  │   ░  ║ └╥┘┌─┐   
   q_2: ┤ H ├─░────────────────■────┼─────────────────┼────■─────────────────■────┼─────────────────┼────■───░──╫──╫─┤M├───
        ├───┤ ░                     │                 │                           │                 │        ░  ║  ║ └╥┘┌─┐
   q_3: ┤ H ├─░─────────────────────■─────────────────■───────────────────────────■─────────────────■────────░──╫──╫──╫─┤M├
        └───┘ ░                                                                                              ░  ║  ║  ║ └╥┘
meas: 4/════════════════════════════════════════════════════════════════════════════════════════════════════════╩══╩══╩══╩═
                                                                                                                0  1  2  3 

*=================      simple_qcrank_EscherHands_backAer.py
Uses Aer
encode 2 sequnces of real numbers with  QCrank using  nq_data=2 qubits and common address qubits
compute vector : averag or difference
(optional) change relative weights

"--mathOp", choices=['add','sub','none'],
--exportQPY", help="export circuits in QPY format", .qpy file can be inspected using dump_QPY_circs.py

Plot residua with       plot_EsherHands.py

 backend: aer
uses backRun

circ_orig depth_aziz: {'cx': 6, '2q': 6, '3q': 0, '4q+': 4, '1q': 9} , ops: {'ry': 10, 'cx': 10, 'barrier': 4, 'measure': 4, 'h': 2, 'rz': 2, 'qubits': 4}
                    ░ ┌───────────────┐     ┌───┐┌─────────────────┐┌───┐┌────────────────┐                        ┌───┐»
   q_0: ────────────░─┤ R(1.2402,π/2) ├─────┤ X ├┤ R(-0.27008,π/2) ├┤ X ├┤ R(-0.4448,π/2) ├────────────────────────┤ X ├»
                    ░ ├───────────────┤┌───┐└─┬─┘├─────────────────┤└─┬─┘└─────┬───┬──────┘┌─────────────────┐┌───┐└─┬─┘»
   q_1: ────────────░─┤ R(2.0179,π/2) ├┤ X ├──┼──┤ R(0.001959,π/2) ├──┼────────┤ X ├───────┤ R(-0.61621,π/2) ├┤ X ├──┼──»
        ┌─────────┐ ░ └───────────────┘└─┬─┘  │  └─────────────────┘  │        └─┬─┘       └─────────────────┘└─┬─┘  │  »
   q_2: ┤ U2(0,π) ├─░────────────────────■────┼───────────────────────■──────────┼──────────────────────────────■────┼──»
        ├─────────┤ ░                         │                                  │                                   │  »
   q_3: ┤ U2(0,π) ├─░─────────────────────────■──────────────────────────────────■───────────────────────────────────■──»
        └─────────┘ ░                                                                                                   »
meas: 4/════════════════════════════════════════════════════════════════════════════════════════════════════════════════»
                                                                                                                        »
«         ┌────────────────┐┌───┐      ░                 ┌────────────┐┌───┐┌─────────────┐ ░  ░ ┌─┐         
«   q_0: ─┤ R(0.41975,π/2) ├┤ X ├──────░──────────────■──┤ R(π/4,π/2) ├┤ X ├┤ R(-π/4,π/2) ├─░──░─┤M├─────────
«        ┌┴────────────────┤└─┬─┘┌───┐ ░ ┌─────────┐┌─┴─┐└┬──────────┬┘└─┬─┘└─────────────┘ ░  ░ └╥┘┌─┐      
«   q_1: ┤ R(-0.30534,π/2) ├──┼──┤ X ├─░─┤ U1(π/2) ├┤ X ├─┤ U1(-π/2) ├───■──────────────────░──░──╫─┤M├──────
«        └─────────────────┘  │  └─┬─┘ ░ └─────────┘└───┘ └──────────┘                      ░  ░  ║ └╥┘┌─┐   
«   q_2: ─────────────────────■────┼───░────────────────────────────────────────────────────░──░──╫──╫─┤M├───
«                                  │   ░                                                    ░  ░  ║  ║ └╥┘┌─┐
«   q_3: ──────────────────────────■───░────────────────────────────────────────────────────░──░──╫──╫──╫─┤M├
«                                      ░                                                    ░  ░  ║  ║  ║ └╥┘
«meas: 4/═════════════════════════════════════════════════════════════════════════════════════════╩══╩══╩══╩═
«                                                                                                 0  1  2  3 
M: acquire backend: aer


*=================              ./ehands_grad_smooth_func1d_backAer.py
 backend: aer
uses backRun


  --nqAddr NQADDR       size of address registers
  -i NUMSAMPLE, --numSample NUMSAMPLE

 -O {grad,smooth,conv,mask}, --imgOp {grad,smooth,conv,mask}

Computes gradient of 1D func or smooths noisy 1D func
 encode 2 sequnces of real numbers using QCrank using 2  nq_data qubits
 compute vector : averag or difference

fixed weights=1/2  in EscherHands

 ./plot_EsherHands.py  --expName ibm_kgpamp  -Y
   ./plot_grad_smooth.py  --expName ibm_kgpamp  -Y


